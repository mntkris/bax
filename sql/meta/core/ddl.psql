-- WIP
--set search_path to meta;

--drop table if exists ddlfields cascade;
--drop procedure if exists fillddlfields;
CREATE TABLE ddlfields (
  kind FieldKind,
  parenttype Ident,
  id TEXT,
  name Ident,
  type Type,
  -- ---------------------------
  ispk BOOL DEFAULT FALSE,
  desttable Ident DEFAULT NULL,
  destfield Ident DEFAULT NULL,
  cascade BOOL DEFAULT NULL,
  -- ---------------------------
  notempty BOOL NOT NULL DEFAULT FALSE,
  indexed BOOL NOT NULL DEFAULT FALSE,
  isunique BOOL NOT NULL DEFAULT FALSE,
  props Prop[] NOT NULL DEFAULT '{}',
  validations Validation[] NOT NULL DEFAULT '{}',
  -- ---------------------------
  UNIQUE (parenttype, id),
  PRIMARY KEY (parenttype, name)
);

CREATE PROCEDURE fillddlfields() AS $BODY$
#variable_conflict use_variable
DECLARE
  tpe types%ROWTYPE;
BEGIN
  FOR tpe IN SELECT * FROM compositetypes ORDER BY serial LOOP
	
    INSERT INTO ddlfields(
      kind, parenttype, id, name, type, ispk) --notempty
    SELECT sf.kind, sf.ownertype, sf.id::TEXT, sf.name, sf.type, 
      COALESCE(tpe.kind = 'table' AND sf.name=ANY(t.pk), FALSE)
    FROM scalarfields sf
    LEFT JOIN tables t ON t.name = sf.ownertype
    WHERE sf.ownertype = tpe.name;

    INSERT INTO ddlfields(kind, parenttype, id, name, type)
    SELECT kind, ownertype, id::TEXT, name, type
    FROM compositefields 
    WHERE ownertype = tpe.name AND inlineprefix IS NULL;

    INSERT INTO ddlfields(kind, parenttype, id, name, type)
    SELECT tf.kind, cf.ownertype, cf.id || '-' || tf.id, 
      cf.inlineprefix || tf.name, tf.type
    FROM compositefields cf
    JOIN ddlfields tf ON cf.type = tf.parenttype
    WHERE cf.ownertype = tpe.name AND cf.inlineprefix IS NOT NULL;

    INSERT INTO ddlfields(
      kind, parenttype, id, name, type, desttable, destfield, cascade)
    SELECT r.kind, r.ownertype, r.id || '-' || sf.id, pkfname, sf.type, 
      r.destination, pkfname, r.cascade
    FROM refnfields r
    JOIN tables t ON r.destination = t.name,
    UNNEST(t.pk) pkfname
    JOIN scalarfields sf ON sf.name = pkfname
    WHERE r.ownertype = tpe.name AND r.names IS NULL AND sf.ownertype = t.name;

    INSERT INTO ddlfields(
      kind, parenttype, id, name, type, desttable, destfield, cascade)
    SELECT r.kind, r.ownertype, r.id || '-' || sf.id, fk.newname, sf.type,
      r.destination, fk.name, r.cascade 
    FROM refnfields r
    JOIN tables t ON r.destination = t.name, 
    UNNEST(r.names, t.pk) AS fk(newname, name)
    JOIN scalarfields sf ON sf.name = fk.name 
    WHERE r.ownertype = tpe.name AND r.names IS NOT NULL AND sf.ownertype = t.name;
  
  END LOOP;	
END
$BODY$ LANGUAGE PLPGSQL;
--call fillddlfields();
--select * from ddlfields order by 2,3;

CREATE FUNCTION astext(ns Namespace) RETURNS TEXT AS $BODY$
  SELECT CASE CARDINALITY(ns)
    WHEN 0 THEN ''
    WHEN 1 THEN ns[1] || '.'
    ELSE ns[1] || '.' || ARRAY_TO_STRING(ns[2:], '_') || '_'
  END;
$BODY$ LANGUAGE SQL IMMUTABLE;
--select (('aa-bb-cc').arr).astext;

CREATE FUNCTION schema(ns Namespace) RETURNS TEXT AS $BODY$
  SELECT CASE CARDINALITY(ns)
    WHEN 0 THEN ''
    ELSE ns[1] || '.'
  END;
$BODY$ LANGUAGE SQL IMMUTABLE;

-- =================================================================

CREATE FUNCTION ddlcreate(scalar scalartypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN FORMAT(
    $DDL$CREATE DOMAIN %s%s AS %s;$DDL$,
    (scalar.ns).astext, scalar.name, scalar.pgtype);
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

CREATE FUNCTION ddlcreatescalartypes() RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN STRING_AGG((s).ddlcreate, E'\n\n' ORDER BY s.serial)
  FROM scalartypes s;
END
$BODY$ LANGUAGE PLPGSQL;


CREATE FUNCTION ddlcreate(field ddlfields) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN FORMAT($DDL$  %s %s$DDL$, field.name, field.type);
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;
--select (f).ddlcreate from ddlfields f;

CREATE FUNCTION ddlcreate(cmp compositetypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
DECLARE
  fields TEXT;
  qname TEXT;
BEGIN
  SELECT STRING_AGG((f).ddlcreate, E',\n' ORDER BY f.id) INTO fields
  FROM ddlfields f WHERE f.parenttype = cmp.name;

  qname = (cmp.ns).astext || cmp.name;
  -- IF tpe.kind = 'composite' THEN
  RETURN FORMAT(
    E'CREATE TYPE %s_T AS (\n%s\n);\nCREATE DOMAIN %s AS %s_T;', 
    qname, fields, qname, qname);
  -- END IF;
  -- IF tpe.kind = 'table' THEN
  --   RETURN FORMAT(E'CREATE TABLE %s%s (\n%s\n);',
  --                 (tpe.ns).astext, tpe.name, fields);
  -- END IF;
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

CREATE FUNCTION ddlcreatecompositetypes() RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  CALL fillddlfields();
  RETURN STRING_AGG((c).ddlcreate, E'\n\n' ORDER BY c.serial)
  FROM compositetypes c;
END
$BODY$ LANGUAGE PLPGSQL;

-- TODO tables

-- ==================================================================

CREATE FUNCTION propsql(
  sch Ident,
  name Ident,
  partype Type,
  rettype Type,
  expr TEXT,
  self Ident DEFAULT 'self'
) RETURNS TEXT AS $BODY$
  SELECT FORMAT(
$FUN$CREATE FUNCTION %s%s(%s %s) RETURNS %s AS $PROP$
  SELECT %s;
$PROP$ LANGUAGE SQL IMMUTABLE;$FUN$,
  	sch, name, self, partype, rettype, expr);
$BODY$ LANGUAGE SQL IMMUTABLE;
--select Prop('as', 'prop', 'INT', 'BOOL', 'self IS NULL');

CREATE FUNCTION ddlprops(scalar scalartypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN STRING_AGG(
    propsql((scalar.ns).schema, prop.name, scalar.name, prop.rettype, prop.expr), E'\n')
  FROM UNNEST(scalar.props) prop;
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

CREATE FUNCTION ddlscalartypesprops() RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN STRING_AGG((s).ddlprops, E'\n\n' ORDER BY s.serial)
  FROM scalartypes s;
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

-- ==================================================================

CREATE FUNCTION ddldefault(scalar scalartypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN FORMAT(
    $DDL$ALTER DOMAIN %s%s SET DEFAULT %s;$DDL$,
    (scalar.ns).schema, scalar.name, scalar.initial);
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;


CREATE FUNCTION ddlscalartypesdefaults() RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN STRING_AGG((s).ddldefault, E'\n\n' ORDER BY s.serial)
  FROM scalartypes s WHERE s.initial IS NOT NULL;
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;





