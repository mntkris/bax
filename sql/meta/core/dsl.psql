CREATE TYPE Prop_T AS (
  -- sch from type/field definition
  -- partype also
  name Ident,
  rettype Type,
  expr TEXT,
  self Ident,
  stored BOOL,
  indexed BOOL,
  isunique BOOL
);
CREATE DOMAIN Prop AS Prop_T
  CONSTRAINT notempty CHECK (
    (VALUE).name.notempty AND
    (VALUE).rettype.notempty AND
    (VALUE).expr.notempty AND
    (VALUE).self.notempty);
CREATE FUNCTION Prop(
  name Ident,
  rettype Type,
  expr TEXT,
  self Ident DEFAULT 'self',
  stored BOOL DEFAULT FALSE,  -- ????
  indexed BOOL DEFAULT FALSE, -- ????
  isunique BOOL DEFAULT FALSE -- ????
) RETURNS Prop AS $BODY$
  SELECT ROW(name, rettype, expr, self, stored, indexed, isunique)::Prop;
$BODY$ LANGUAGE SQL IMMUTABLE;


CREATE TYPE Validation_T AS (
  propname Ident,
  message TEXT
);
CREATE DOMAIN Validation AS Validation_T;


CREATE TYPE TypeKind AS ENUM ('scalar', 'enum', 'composite', 'table');

CREATE TABLE types (
  serial SERIAL,
  kind TypeKind NOT NULL,
  ns Namespace,
  name Ident PRIMARY KEY,
  initial Initial DEFAULT NULL,
  notempty BOOL NOT NULL DEFAULT FALSE,
  props Prop[] NOT NULL DEFAULT '{}',
  validations Validation[] NOT NULL DEFAULT '{}'
);

CREATE TABLE scalartypes (
  kind TypeKind NOT NULL DEFAULT 'scalar',
  name Ident PRIMARY KEY,
  pgtype PgType NOT NULL,
  indexed BOOL NOT NULL DEFAULT FALSE,
  isunique BOOL NOT NULL DEFAULT FALSE
) INHERITS (types);

CREATE TABLE enumtypes (
  kind TypeKind NOT NULL DEFAULT 'enum',
  values TEXT[]
  -- TODO
) INHERITS (scalartypes);

-- todo range

CREATE TABLE compositetypes (
  kind TypeKind NOT NULL DEFAULT 'composite',
  name Ident PRIMARY KEY
) INHERITS (types);

CREATE TABLE tables (
  kind TypeKind NOT NULL DEFAULT 'table',
  name Ident PRIMARY KEY,
  pk Ident[]
) INHERITS (compositetypes);

--

CREATE TYPE FieldKind AS ENUM ('scalar', 'composite', 'refn', 'ref1');
CREATE FUNCTION fieldkind(s TEXT) RETURNS FieldKind AS $BODY$
  SELECT s::FieldKind;
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE TABLE fields(
  serial SERIAL,
  kind FieldKind NOT NULL, 
  ownertype Ident NOT NULL REFERENCES compositetypes(name),
  id INT NOT NULL CHECK (id BETWEEN 100 AND 999),
  name Ident NOT NULL,
  initial Initial DEFAULT NULL,
  notempty BOOL NOT NULL DEFAULT FALSE,
  props Prop[] NOT NULL DEFAULT '{}',
  validations Validation[] NOT NULL DEFAULT '{}',
  description Description
);

CREATE TABLE scalarfields(
  kind FieldKind NOT NULL DEFAULT 'scalar',
  type Type NOT NULL REFERENCES scalartypes(name),
  indexed BOOL NOT NULL DEFAULT FALSE,
  isunique BOOL NOT NULL DEFAULT FALSE,
  UNIQUE (ownertype, id)
) INHERITS (fields);

CREATE TABLE compositefields(
  kind FieldKind NOT NULL DEFAULT 'composite',
  type Type NOT NULL REFERENCES compositetypes(name),
  inlineprefix TEXT, -- if NULL then not expanded
  UNIQUE (ownertype, id)
) INHERITS (fields);

CREATE TABLE refnfields(
  kind FieldKind NOT NULL DEFAULT 'refn',
  destination Ident NOT NULL REFERENCES tables(name),
  cascade BOOL DEFAULT FALSE,
  names Ident[],
  UNIQUE (ownertype, id)
) INHERITS (fields);

CREATE TABLE ref1fields(
  kind FieldKind NOT NULL DEFAULT 'ref1',
  UNIQUE (ownertype, id)
) INHERITS (refnfields);

-- ============================================================

CREATE TYPE ScalarExt_T AS (
  type Ident
);
CREATE DOMAIN ScalarExt AS ScalarExt_T
  CONSTRAINT notempty CHECK (
    (VALUE).type.notempty);
CREATE FUNCTION ScalarExt (
  type Type,
  indexed BOOL DEFAULT FALSE,
  isunique BOOL DEFAULT FALSE
) RETURNS ScalarExt AS $BODY$
  SELECT ROW(type)::ScalarExt;
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE TYPE CompositeExt_T AS (
  type Type,
  inlineprefix TEXT
);
CREATE DOMAIN CompositeExt AS CompositeExt_T
  CONSTRAINT notempty CHECK (
    (VALUE).type.notempty);
CREATE FUNCTION CompositeExt (
  type Ident,
  inlineprefix TEXT DEFAULT NULL
) RETURNS CompositeExt AS $BODY$
  SELECT ROW(type, inlineprefix)::CompositeExt;
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE TYPE RefNExt_T AS (
  destination Ident,
  cascade BOOL,
  names Ident[]
);
CREATE DOMAIN RefNExt AS RefNExt_T
  CONSTRAINT notempty CHECK (
    (VALUE).destination.notempty AND
    (VALUE).cascade.notempty);
CREATE FUNCTION RefNExt (
  destination Ident,
  cascade BOOL DEFAULT FALSE,
  names Ident[] DEFAULT ARRAY[]::Ident[]
) RETURNS RefNExt AS $BODY$
  SELECT ROW(destination, cascade, names)::RefNExt;
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE TYPE Ref1Ext_T AS (
  destination Ident,
  cascade BOOL,
  names Ident[]
);
CREATE DOMAIN Ref1Ext AS Ref1Ext_T
  CONSTRAINT notempty CHECK (
    (VALUE).destination.notempty AND
    (VALUE).cascade.notempty);
CREATE FUNCTION Ref1Ext (
  destination Ident,
  cascade BOOL DEFAULT FALSE,
  names Ident[] DEFAULT ARRAY[]::Ident[]
) RETURNS Ref1Ext AS $BODY$
  SELECT (destination, cascade, names)::Ref1Ext;
$BODY$ LANGUAGE SQL IMMUTABLE;


CREATE TYPE Field_T AS (
  id INT,
  name Ident,
  initial Initial,
  notempty BOOL,
  indexed BOOL,
  isunique BOOL,
  props Prop[],
  validations Validation[],
  description Description,
  scalarext ScalarExt,
  compositeext CompositeExt,
  refnext RefNExt,
  ref1ext Ref1Ext
);
--
CREATE DOMAIN Field AS Field_T
  CONSTRAINT exactlyone CHECK (
    truecount(ARRAY[
      (VALUE).scalarext.notnull,
      (VALUE).compositeext.notnull,
      (VALUE).refnext.notnull,
      (VALUE).ref1ext.notnull
    ]) = 1)
  CONSTRAINT notempty CHECK (
    (VALUE).id.notempty AND
    (VALUE).name.notempty);
--
CREATE FUNCTION Field (
  id INT,
  name Ident,
  initial Initial DEFAULT NULL,
  notempty BOOL DEFAULT FALSE,
  indexed BOOL DEFAULT FALSE,
  isunique BOOL DEFAULT FALSE,
  props Prop[] DEFAULT '{}',
  validations Validation[] DEFAULT '{}',
  description Description DEFAULT NULL,
  scalarext ScalarExt DEFAULT NULL,
  compositeext CompositeExt DEFAULT NULL,
  refnext RefNExt DEFAULT NULL,
  ref1ext Ref1Ext DEFAULT NULL
) RETURNS Field AS $BODY$
  SELECT (
    id, name, initial, notempty, indexed, isunique, props, validations, 
    description, scalarext, compositeext, refnext, ref1ext
  )::Field;
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE FUNCTION Scalar(
  id INT,
  name Ident,
  type Type,
  initial Initial DEFAULT NULL,
  notempty BOOL DEFAULT FALSE,
  indexed BOOL DEFAULT FALSE,
  isunique BOOL DEFAULT FALSE,
  props Prop[] DEFAULT '{}',
  validations Validation[] DEFAULT '{}',
  description Description DEFAULT NULL
) RETURNS Field AS $BODY$
  SELECT Field(
    id, name, initial, notempty, indexed, isunique, props, validations,
    description, scalarext => ScalarExt(type => type));
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE FUNCTION Composite(
  id INT,
  name Ident,
  type Type,
  initial Initial DEFAULT NULL,
  notempty BOOL DEFAULT FALSE,
  indexed BOOL DEFAULT FALSE,
  isunique BOOL DEFAULT FALSE,
  props Prop[] DEFAULT '{}',
  validations Validation[] DEFAULT '{}',
  description Description DEFAULT NULL
) RETURNS Field AS $BODY$
  SELECT Field(
    id, name, initial, notempty, indexed, isunique, props, validations, description,
    compositeext => CompositeExt(type => type));
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE FUNCTION Inline(
  id INT,
  type Type,
  prefix TEXT DEFAULT NULL,
  initial Initial DEFAULT NULL,
  notempty BOOL DEFAULT FALSE,
  indexed BOOL DEFAULT FALSE,
  isunique BOOL DEFAULT FALSE,
  props Prop[] DEFAULT '{}',
  validations Validation[] DEFAULT '{}',
  description Description DEFAULT NULL
) RETURNS Field AS $BODY$
  SELECT Field(
    id, 'inline_' || id, initial, notempty, indexed, isunique, props, validations, description,
    compositeext => CompositeExt(type => type, inlineprefix => prefix));
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE FUNCTION RefN(
  id INT,
  destination Ident,
  cascade BOOL DEFAULT FALSE,
  names Text DEFAULT NULL,
  initial Initial DEFAULT NULL,
  notempty BOOL DEFAULT TRUE,
  indexed BOOL DEFAULT FALSE,
  props Prop[] DEFAULT '{}',
  validations Validation[] DEFAULT '{}',
  description Description DEFAULT NULL
) RETURNS Field AS $BODY$
  SELECT Field(id, 'refn_' || id, initial, notempty, indexed, FALSE, props, validations, description,
  refnext => RefNExt(destination => destination, cascade => cascade, names => names.arr));
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE FUNCTION Ref1(
  id INT,
  destination Ident,
  cascade BOOL DEFAULT FALSE,
  names Text DEFAULT NULL,
  initial Initial DEFAULT NULL,
  notempty BOOL DEFAULT TRUE,
  indexed BOOL DEFAULT FALSE,
  props Prop[] DEFAULT '{}',
  validations Validation[] DEFAULT '{}',
  description Description DEFAULT NULL
) RETURNS Field AS $BODY$
  SELECT Field(
    id, 'ref1_' || id, initial, notempty, indexed, TRUE, props, validations, description,
    ref1ext => Ref1Ext(destination => destination, cascade => cascade, names => names.arr));
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE FUNCTION fields(VARIADIC fieldsarr Field[]) RETURNS Field[] AS $BODY$
  SELECT fieldsarr;
$BODY$ LANGUAGE SQL IMMUTABLE;

-- ===================================================

CREATE TYPE ScalarType_T AS (
  ns Namespace,
  name Ident,
  pgtype PgType,
  initial Initial,
  notempty BOOL,
  props Prop[],
  validations Validation[]
);
CREATE DOMAIN ScalarType AS ScalarType_T
  CONSTRAINT notempty CHECK (
    (VALUE).ns.notempty AND 
    (VALUE).name.notempty AND 
    (VALUE).pgtype.notempty);
CREATE FUNCTION ScalarType (
  ns TEXT,
  name Ident,
  pgtype PgType,
  initial Initial DEFAULT NULL,
  notempty BOOL DEFAULT FALSE,
  props Prop[] DEFAULT '{}',
  validations Validation[] DEFAULT '{}'
) RETURNS ScalarType AS $BODY$
  SELECT ROW(ns.arr, name, pgtype, initial, notempty, props, validations)::ScalarType
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE PROCEDURE def_scalartypes(VARIADIC sts ScalarType[]) AS $BODY$
#variable_conflict use_variable
BEGIN
  INSERT INTO scalartypes(ns, name, pgtype, initial, notempty, props, validations)
  SELECT st.ns, st.name, st.pgtype, st.initial, st.notempty, st.props, st.validations
  FROM UNNEST(sts) st;
END
$BODY$ LANGUAGE PLPGSQL;

-- -------------------------------------------------------

CREATE TYPE CompositeType_T AS (
  ns Namespace,
  name Ident,
  fields Field[],
  initial Initial,
  notempty BOOL,
  props Prop[],
  validations Validation[]
);
CREATE DOMAIN CompositeType AS CompositeType_T
  CONSTRAINT notempty CHECK (
    (VALUE).ns.notempty AND
    (VALUE).name.notempty AND
    (VALUE).fields.notempty);
CREATE FUNCTION CompositeType (
  ns TEXT,
  name Ident,
  fields Field[],
  initial Initial DEFAULT NULL,
  notempty BOOL DEFAULT FALSE,
  props Prop[] DEFAULT '{}',
  validations Validation[] DEFAULT '{}'
) RETURNS CompositeType AS $BODY$
  SELECT (ns.arr, name, fields, initial, notempty, props, validations)::CompositeType;
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE PROCEDURE def_compositetypes(VARIADIC cts CompositeType[]) AS $BODY$
#variable_conflict use_variable
BEGIN
  INSERT INTO compositetypes(ns, name, initial, notempty, props, validations)
  SELECT ct.ns, ct.name, ct.initial, ct.notempty, ct.props, ct.validations
  FROM UNNEST(cts) ct;

  INSERT INTO scalarfields(
    ownertype, id, name, notempty, indexed, isunique, props, validations, description, type)
  SELECT ct.name, f.id, f.name, f.notempty, f.indexed, f.isunique, f.props, f.validations,
    f.description, (f.scalarext).type
  FROM UNNEST(cts) ct, UNNEST(ct.fields) f WHERE (f.scalarext).notnull;

  INSERT INTO compositefields(
    ownertype, id, name, notempty, props, validations, description, type, inlineprefix)
  SELECT ct.name, f.id, f.name, f.notempty, f.props, f.validations, f.description, 
    (f.compositeext).type, (f.compositeext).inlineprefix 
  FROM UNNEST(cts) ct, UNNEST(ct.fields) f WHERE (f.compositeext).notnull;

  RETURN;
END
$BODY$ LANGUAGE PLPGSQL;

-- =================================================================

CREATE TYPE GenericTable_T AS (
  ns Namespace,
  name Ident,
  pk Ident[],
  fields Field[]
);
CREATE DOMAIN GenericTable AS GenericTable_T
  CONSTRAINT notempty CHECK (
    (VALUE).ns.notempty AND
    (VALUE).name.notempty AND
    (VALUE).pk.notempty AND
    (VALUE).fields.notempty);
CREATE FUNCTION GenericTable (
  ns TEXT,
  name Ident,
  pk TEXT,
  VARIADIC fields Field[]
) RETURNS GenericTable AS $BODY$
  SELECT (ns.arr, name, pk.arr, fields)::GenericTable;
$BODY$ LANGUAGE SQL IMMUTABLE;


CREATE PROCEDURE def_tables(VARIADIC gts GenericTable[]) AS $BODY$
#variable_conflict use_variable
BEGIN
  INSERT INTO tables(ns, name, pk)
  SELECT gt.ns, gt.name, gt.pk FROM UNNEST(gts) gt;

  INSERT INTO scalarfields(
    ownertype, id, name, notempty, indexed, isunique, props, validations, description, type)
  SELECT gt.name, f.id, f.name, f.notempty, f.indexed, f.isunique, f.props, f.validations,
    f.description, (f.scalarext).type
  FROM UNNEST(gts) gt, UNNEST(gt.fields) f WHERE (f.scalarext).notnull;

  INSERT INTO compositefields(
    ownertype, id, name, notempty, indexed, isunique, props, validations, description, type, inlineprefix)
  SELECT gt.name, f.id, f.name, f.notempty, f.indexed, f.isunique, f.props, f.validations, f.description,
    (f.compositeext).type, (f.compositeext).inlineprefix 
  FROM UNNEST(gts) gt, UNNEST(gt.fields) f WHERE (f.compositeext).notnull;

  INSERT INTO refnfields(
    ownertype, id, name, notempty, indexed, isunique, props, validations, description, destination, cascade, names)
  SELECT gt.name, f.id, f.name, f.notempty, f.indexed, f.isunique, f.props, f.validations, f.description,
    (f.refnext).destination, (f.refnext).cascade, (f.refnext).names
  FROM UNNEST(gts) gt, UNNEST(gt.fields) f WHERE (f.refnext).notnull;

  INSERT INTO ref1fields(
    ownertype, id, name, notempty, indexed, isunique, props, validations, description, destination, cascade, names)
  SELECT gt.name, f.id, f.name, f.notempty, f.indexed, f.isunique, f.props, f.validations, f.description,
    (f.ref1ext).destination, (f.ref1ext).cascade, (f.ref1ext).names
  FROM UNNEST(gts) gt, UNNEST(gt.fields) f WHERE (f.ref1ext).notnull;
  
  RETURN;
END
$BODY$ LANGUAGE PLPGSQL;


-- CREATE TABLE ConstraintMessages(
--   name Ident PRIMARY KEY,
--   message TEXT
-- );