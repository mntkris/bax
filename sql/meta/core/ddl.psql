-- WIP
--set search_path to meta;

--drop table if exists ddlfields cascade;
--drop procedure if exists fillddlfields;
CREATE TABLE ddlfields (
  kind FieldKind,
  parenttype Ident,
  id TEXT,
  name Ident,
  type Type,
  -- ---------------------------
  ispk BOOL DEFAULT FALSE,
  desttable Ident DEFAULT NULL,
  destfield Ident DEFAULT NULL,
  cascade BOOL DEFAULT NULL,
  -- ---------------------------
  initial Initial DEFAULT NULL,
  notempty BOOL NOT NULL DEFAULT FALSE,
  indexed BOOL NOT NULL DEFAULT FALSE,
  isunique BOOL NOT NULL DEFAULT FALSE,
  props Prop[] NOT NULL DEFAULT '{}',
  validations Validation[] NOT NULL DEFAULT '{}',
  -- ---------------------------
  UNIQUE (parenttype, id),
  PRIMARY KEY (parenttype, name)
);

CREATE MATERIALIZED VIEW ddlfieldsmv AS
  SELECT f.kind, f.parenttype, f.id, f.name, f.type,
    f.ispk, f.desttable, f.destfield, f.cascade,
    -- ---------------------------
    COALESCE(f.initial, t.initial) initial,
    COALESCE(f.notempty, t.notempty) notempty,
    COALESCE(f.indexed, s.indexed) indexed,
    COALESCE(f.isunique, s.isunique) isunique,
    f.props, f.validations,
    f.initial f_initial, t.initial t_initial,
    f.notempty f_notempty, t.notempty t_notempty,
    f.indexed f_indexed, s.indexed s_indexed,
    f.isunique f_isunique, s.isunique s_isunique
  FROM ddlfields f
  JOIN types t ON f.type = t.name
  LEFT JOIN scalartypes s ON f.type = s.name
  WITH NO DATA;

CREATE PROCEDURE fillddlfields() AS $BODY$
#variable_conflict use_variable
DECLARE
  tpe types%ROWTYPE;
BEGIN
  FOR tpe IN SELECT * FROM compositetypes ORDER BY serial LOOP
	
    INSERT INTO ddlfields(
      kind, parenttype, id, name, type, ispk, initial, notempty,
      indexed, isunique, props, validations)
    SELECT sf.kind, sf.ownertype, sf.id::TEXT, sf.name, sf.type, 
      COALESCE(tpe.kind = 'table' AND sf.name=ANY(t.pk), FALSE),
      sf.initial, sf.notempty, sf.indexed, sf.isunique,
      sf.props, sf.validations
    FROM scalarfields sf
    LEFT JOIN tables t ON t.name = sf.ownertype
    WHERE sf.ownertype = tpe.name;

    INSERT INTO ddlfields(
      kind, parenttype, id, name, type,
      initial, notempty, props, validations)
    SELECT kind, ownertype, id::TEXT, name, type,
      initial, notempty, props, validations
    FROM compositefields 
    WHERE ownertype = tpe.name AND inlineprefix IS NULL;

    -- TODO lift tpe's props and validations with prefixing
    INSERT INTO ddlfields(
      kind, parenttype, id, name, type,
      initial, notempty, props, validations)
    SELECT tf.kind, cf.ownertype, cf.id || '-' || tf.id, 
      cf.inlineprefix || tf.name, tf.type,
      cf.initial, cf.notempty, cf.props, cf.validations
    FROM compositefields cf
    JOIN ddlfields tf ON cf.type = tf.parenttype
    WHERE cf.ownertype = tpe.name AND cf.inlineprefix IS NOT NULL;

    INSERT INTO ddlfields(
      kind, parenttype, id, name, type, desttable, destfield, cascade,
      initial, notempty, props, validations)
    SELECT r.kind, r.ownertype, r.id || '-' || sf.id, pkfname, sf.type, 
      r.destination, pkfname, r.cascade,
      r.initial, r.notempty, r.props, r.validations
    FROM refnfields r
    JOIN tables t ON r.destination = t.name,
    UNNEST(t.pk) pkfname
    JOIN scalarfields sf ON sf.name = pkfname
    WHERE r.ownertype = tpe.name AND r.names IS NULL AND sf.ownertype = t.name;

    INSERT INTO ddlfields(
      kind, parenttype, id, name, type, desttable, destfield, cascade,
      initial, notempty, props, validations)
    SELECT r.kind, r.ownertype, r.id || '-' || sf.id, fk.newname, sf.type,
      r.destination, fk.name, r.cascade,
      r.initial, r.notempty, r.props, r.validations
    FROM refnfields r
    JOIN tables t ON r.destination = t.name, 
    UNNEST(r.names, t.pk) AS fk(newname, name)
    JOIN scalarfields sf ON sf.name = fk.name 
    WHERE r.ownertype = tpe.name AND r.names IS NOT NULL AND sf.ownertype = t.name;
  
  END LOOP;

  REFRESH MATERIALIZED VIEW ddlfieldsmv;

END
$BODY$ LANGUAGE PLPGSQL;
--call fillddlfields();
--select * from ddlfields order by 2,3;


-- =================================================================

CREATE FUNCTION ddlcreate(scalar scalartypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN FORMAT(
    $DDL$CREATE DOMAIN %s%s AS %s;$DDL$,
    (scalar.ns).astext, scalar.name, scalar.pgtype);
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;


CREATE FUNCTION ddlcreate(field ddlfields) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN FORMAT($DDL$  %s %s$DDL$, field.name, field.type);
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;
--select (f).ddlcreate from ddlfields f;

CREATE FUNCTION ddlcreate(cmp compositetypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
DECLARE
  fields TEXT;
  qname TEXT;
BEGIN
  SELECT STRING_AGG((f).ddlcreate, E',\n' ORDER BY f.id) INTO fields
  FROM ddlfields f WHERE f.parenttype = cmp.name;

  qname = (cmp.ns).astext || cmp.name;
  -- IF tpe.kind = 'composite' THEN
  RETURN FORMAT(
    E'CREATE TYPE %s_T AS (\n%s\n);\nCREATE DOMAIN %s AS %s_T;', 
    qname, fields, qname, qname);
  -- END IF;
  -- IF tpe.kind = 'table' THEN
  --   RETURN FORMAT(E'CREATE TABLE %s%s (\n%s\n);',
  --                 (tpe.ns).astext, tpe.name, fields);
  -- END IF;
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

-- TODO tables

CREATE FUNCTION ddlcreates() RETURNS TEXT AS $BODY$
#variable_conflict use_variable
DECLARE
  scalars TEXT;
  composites TEXT;
BEGIN
  SELECT STRING_AGG(
    (s).ddlcreate, E'\n\n' ORDER BY s.serial) INTO scalars
  FROM scalartypes s;
  
  SELECT STRING_AGG(
    (c).ddlcreate, E'\n\n' ORDER BY c.serial) INTO composites
  FROM ONLY compositetypes c;

-- TODO tables
  RETURN CONCAT_WS(E'\n\n', scalars, composites);
END
$BODY$ LANGUAGE PLPGSQL;


-- ==================================================================

CREATE FUNCTION propsql(
  sch Ident,
  name Ident,
  partype Type,
  rettype Type,
  expr TEXT,
  self Ident DEFAULT 'self'
) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN FORMAT(
$FUN$CREATE FUNCTION %s%s(%s %s%s) RETURNS %s AS $PROP$
  SELECT %s;
$PROP$ LANGUAGE SQL IMMUTABLE; $FUN$,
  	sch, name, self, sch, partype, rettype, expr);
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

CREATE FUNCTION ddlprops(scalar scalartypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN STRING_AGG(
    propsql((scalar.ns).schema, prop.name, scalar.name, prop.rettype, prop.expr), E'\n')
  FROM UNNEST(scalar.props) prop;
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

CREATE FUNCTION ddldefault(scalar scalartypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN CASE WHEN (scalar).initial.notnull THEN
    FORMAT(
      $DDL$ALTER DOMAIN %s%s SET DEFAULT %s;$DDL$,
      (scalar.ns).schema, scalar.name, scalar.initial)
    ELSE NULL
  END;
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

CREATE FUNCTION ddlalter(scalar scalartypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN CONCAT_WS(E'\n', (scalar).ddlprops, (scalar).ddldefault);
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

-- ----

CREATE FUNCTION ddlconstructor(cmp compositetypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
DECLARE
  params TEXT;
  attrs TEXT;
  qname TEXT;
BEGIN
  SELECT 
    STRING_AGG(CONCAT(
      FORMAT($PARAM$  %s %s$PARAM$, name, type),
      CASE WHEN (f.initial).notnull THEN FORMAT(' DEFAULT %s', f.initial) ELSE '' END),
      E',\n' ORDER BY (f.initial).notempty, f.id),
    STRING_AGG(name,
      E',\n    ' ORDER BY (f.initial).notempty, f.id) INTO params, attrs
  FROM ddlfieldsmv f WHERE cmp.name = f.parenttype;
  
  qname = (cmp.ns).astext || cmp.name;
  RETURN FORMAT(
$FUN$CREATE FUNCTION %s(
%s
) RETURNS %s AS $CONSTR$
  SELECT ROW(
    %s)::%s;
$CONSTR$ LANGUAGE SQL IMMUTABLE;$FUN$,
    qname, params, qname, attrs, qname);
-- TODO snippets : constructor etc
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

CREATE FUNCTION ddlprops(cmp compositetypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
BEGIN
  RETURN STRING_AGG(
    propsql((cmp.ns).schema, prop.name, cmp.name, prop.rettype, prop.expr), E'\n')
  FROM UNNEST(cmp.props) prop;
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;


CREATE FUNCTION ddlalter(cmp compositetypes) RETURNS TEXT AS $BODY$
#variable_conflict use_variable
DECLARE
  constructor TEXT;
  props TEXT;
BEGIN
  constructor = (cmp).ddlconstructor;

  props = (cmp).ddlprops;

  RETURN CONCAT_WS(E'\n\n', constructor, props);
END
$BODY$ LANGUAGE PLPGSQL IMMUTABLE;

CREATE FUNCTION ddlalters() RETURNS TEXT AS $BODY$
#variable_conflict use_variable
DECLARE
  scalars TEXT;
  composites TEXT;
BEGIN
  SELECT STRING_AGG(
    (s).ddlalter, E'\n\n' ORDER BY s.serial) INTO scalars
  FROM scalartypes s;

  SELECT STRING_AGG(
    (c).ddlalter, E'\n\n' ORDER BY c.serial) INTO composites
  FROM ONLY compositetypes c;

-- TODO tables
  RETURN CONCAT_WS(E'\n\n', scalars, composites);
END
$BODY$ LANGUAGE PLPGSQL;

CREATE FUNCTION arr(VARIADIC fieldsarr Field[]) RETURNS Field[] AS $BODY$
  SELECT fieldsarr;
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE FUNCTION arr(VARIADIC propsarr Prop[]) RETURNS Prop[] AS $BODY$
  SELECT propsarr;
$BODY$ LANGUAGE SQL IMMUTABLE;
-- ==================================================================


-- =================================================================

CREATE TYPE DDLRet AS (
  creates TEXT,
  alters TEXT
);
CREATE FUNCTION DDLRet(
  creates TEXT,
  alters TEXT
) RETURNS DDLRet AS $BODY$
  SELECT ROW(creates, alters);
$BODY$ LANGUAGE SQL IMMUTABLE;

CREATE FUNCTION ddl() RETURNS DDLRet AS $BODY$
#variable_conflict use_variable
DECLARE
  creates TEXT;
  alters TEXT;
BEGIN
  CALL fillddlfields();
  creates = ddlcreates();
  alters = ddlalters();
  RETURN DDLRet(creates, alters);
END
$BODY$ LANGUAGE PLPGSQL;



